<!DOCTYPE html>
<html lang="en">
	<head>
		<title>10.0.0.3</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			@font-face {
				font-family: digital;
				src: url(font/digital-7.ttf);
			}
			
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info, #infoS {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			
			#info a, .button, #infoS a { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
			.phonebutton{
				background:rgba(255,255,255,0);
				width:30px;
				height:30px;
				position:fixed;
				display:inline;
				cursor:pointer;
			}
			.phonebutton:hover{
				background:rgba(255,255,255,0.3);

			}
			
			.row1{top: 218px;}
			.row2{top: 250px;}
			.row3{top: 280px;}
			.row4{top: 311px;}
			
			.col1{margin-left: 333px;}
			.col2{margin-left: 362px;}
			.col3{margin-left: 393px;}
			
			.window3d{
				margin:0 auto;padding:30px;max-width:600px;background:#101010;margin-top:30px
			}
			
			#poemback{
				background: url('img/poem.png'); background-size:cover;margin:10px; padding:30px;text-align:left;color:black; font-size:14pt;
			}
			
			#safeinput{
				position: fixed;
				display: inline;
				cursor: pointer;
				background: transparent;
				outline: none;
				border: none;
				margin-left: 199px;
				margin-top: 167px;
				width: 121px;
				color: white;
				text-align: center;
				font-family: digital;
				font-size: 16pt;			
			}
			
			#G #bio{
				max-height: 180px !important;
				max-width: 180px!important; 
				min-height: 180px!important;
				min-width: 180px!important;
			}
			
			#infoS{
				width: 100%;
			}
			#infoS .window3d{
				width:25% !important;
				left: 0;
				position: absolute;
			}
			#blocker{
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}
			#instructions{
				    width: 100%;
					height: 100%;
					display: -webkit-box;
					display: -moz-box;
					display: box;
					-webkit-box-orient: horizontal;
					-moz-box-orient: horizontal;
					box-orient: horizontal;
					-webkit-box-pack: center;
					-moz-box-pack: center;
					box-pack: center;
					-webkit-box-align: center;
					-moz-box-align: center;
					box-align: center;
					color: #ffffff;
					text-align: center;
					cursor: pointer;
			}
		</style>
		
<link rel="stylesheet" type="text/css" href="../css/nulwo.css">
<link rel="stylesheet" type="text/css" href="styles/style.css">
	</head>

	<body>
	<video id="video" onended="startH()" webkit-playsinline style="display:none">
			<source src="mod/vid.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>
		
		<div id="blocker" style="display: -webkit-box;">

			<div id="instructions">
				<span style="font-size:40px">Click to obtain control</span>
				<br>
				(W, A, S, D = Move, MOUSE = Look around)
			</div>

		</div>
		
		
	<!--<div style="width:100%; height:100vh; background:#101010; text-align:center;"><div style="position:relative;">LOADING</div></div>
	--><div id="overlay"></div>
	<div id="overlay2"></div>
		<div id="soundSwitch" onclick="playAngela(0);" style="position:absolute; top:0;right:20px; height:30px; width:30px;"><img src="img/soundon.png"></div>
		<div id="info">		</div>
		<div id="infoS">		</div>
	<div style="width:100%; position: absolute; bottom: 0;">
		<table style="width:860px; margin: 0 auto; position:relative;" id="G">
		  <tr>
			<th style="width:1%; text-align:right;">
				<div id="bio">
					<img id="Gimg" src="img/G/angry.png">
				</div>
			</th>
			<th style="width:40%;text-align:left;position:relative;">
				<div style="top: -25px;	position: absolute;">
					<div id="answer1"  onclick="" class="answer">
						<div id="charge1" style="background:red; position:relative; width:0%; color:white;">0%</div>
					</div>
					<div id="answer2"  onclick="" class="answer">
						 <div id="charge2" style="background:red; position:relative; width:0%; color:white;">0%</div>
					</div>
					<div id="answer3"  onclick="" class="answer">
						 <div id="charge3" style="background:red; position:relative; width:0%; color:white;;">0%</div>
					</div>
				</div>
				<div id="Gtext" class="Gtext">
					Okey, First PC. Let's find out if we can get to the second PC, 10.0.0.2.Look around and see if any object around is interactuable.
				</div>
			</th>
			<th id="next" onclick="" style="width:6%; displaY:none;">
				==>
			</th>
		  </tr>
		</table>
	</div>

		<script src="../scripts/three.min.js"></script>
		<script src="https://threejs.org/build/three.min.js"></script>

		<script src="../scripts/DDSLoader.js"></script>
		<script src="../scripts/MTLLoader.js"></script>
		<script src="../scripts/OBJLoader.js"></script>
		<script src="../scripts/OrbitControls.js"></script>
		<script src="../scripts/Mirror.js"></script>
		<script src="../scripts/Detector.js"></script>
		<script src="../scripts/stats.min.js"></script>

		
		
		<script src="js/ConvolutionShader.js"></script>
		<script src="js/CopyShader.js"></script>

		<script src="js/EffectComposer.js"></script>
		<script src="js/RenderPass.js"></script>
		<script src="js/MaskPass.js"></script>
		<script src="js/BloomPass.js"></script>
		<script src="js/ShaderPass.js"></script>
		
		<script src="js/CurveExtras.js"></script>
		
		<script src="js/FBXLoader2.js"></script>
		
		<script src="https://code.jquery.com/jquery-1.10.2.js"></script>
		<script src="../scripts/jquery-1.6.3.min.js"></script>
		<script src="../scripts/DTMFgenerator.js"></script>
		<script src="scripts/PointerLockControls.js"></script>
		<script src="scripts/script.js"></script>
		<!--DOME-->
		
		<script type="x-shader/x-vertex" id="vertexShader">
			varying vec3 vWorldPosition;
			void main() {
				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">
			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;
			varying vec3 vWorldPosition;
			void main() {
				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
			}
		</script>
		
		<script>
			var container, stats;
			var camera, controls, scene, renderer, raycaster;
			var WIDTH = window.innerWidth;
			var HEIGHT = window.innerHeight;
			var mesh, line;
			var video, texture, material, mesh;
			
			var mouse = new THREE.Vector2(), INTERSECTED;

			var hemiLight;
			var light1;
			var light2;
			var light3;
			var flag = 0;
			var flagrs = 0;
			var mixers = [];
			var mixers2 = [];
			var action, action2;
			var clock = new THREE.Clock();

			
			var geometry
			var objects = [];

			var blocker = document.getElementById( 'blocker' );
			var instructions = document.getElementById( 'instructions' );
			
			
			var controlsEnabled = false;
			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;
			var prevTime = performance.now();
			var velocity = new THREE.Vector3();

			
			var detectHF = 0;
			var screen1;
			var screen2;
			var screen3;
			var asf;
			
			//rays of electricity
			var binormal = new THREE.Vector3();
			var normal = new THREE.Vector3();
			
			var ray1 = new THREE.CatmullRomCurve3( [
				new THREE.Vector3( 0, 10, -10 ), new THREE.Vector3( 10, 0, -10 ),
				new THREE.Vector3( 20, 0, 0 ), new THREE.Vector3( 30, 0, 10 ),
				new THREE.Vector3( 30, 0, 20 ), new THREE.Vector3( 20, 0, 30 ),
				new THREE.Vector3( 10, 0, 30 ), new THREE.Vector3( 0, 0, 30 ),
				new THREE.Vector3( -10, 10, 30 ), new THREE.Vector3( -10, 20, 30 ),
				new THREE.Vector3( 0, 30, 30 ), new THREE.Vector3( 10, 30, 30 ),
				new THREE.Vector3( 20, 30, 15 ), new THREE.Vector3( 10, 30, 10 ),
				new THREE.Vector3( 0, 30, 10 ), new THREE.Vector3( -10, 20, 10 ),
				new THREE.Vector3( -10, 10, 10 ), new THREE.Vector3( 0, 0, 10 ),
				new THREE.Vector3( 10, -10, 10 ), new THREE.Vector3( 20, -15, 10 ),
				new THREE.Vector3( 30, -15, 10 ), new THREE.Vector3( 40, -15, 10 ),
				new THREE.Vector3( 50, -15, 10 ), new THREE.Vector3( 60, 0, 10 ),
				new THREE.Vector3( 70, 0, 0 ), new THREE.Vector3( 80, 0, 0 ),
				new THREE.Vector3( 90, 0, 0 ), new THREE.Vector3( 100, 0, 0 )
			] );
			
			var splines = {
				ray1: ray1
			};
			
			var raymaterial = new THREE.MeshBasicMaterial( { color: 0x00d0fe } );
			
			var wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0, wireframe: true, transparent: true } );
			
			
			var parent, tubeGeometry, group;
			
			var rayparams = {
				spline: 'ray1',
				scale: 4,
				extrusionSegments: 100,
				radiusSegments: 3,
				closed: false,
				animationView: false,
				lookAhead: false,
				cameraHelper: false,
			};
			
			//animationflags and vars
			var toCenter = 0;
			var getHF = 0;
			var dir = new THREE.Vector3(); // create once an reuse it	
			var HF;
			var startpos, endpos;
			
			//constrains and terminal and final
			
			var terminal = 0;
			var area1 = {z1: -72, z2: -40, x1:-45, x2: 45};
			
			var charge1 = 0;
			var charge2 = 0;
			var charge3 = 0;
			var charged1 = 0;
			var charged2 = 0;
			var charged3 = 0;
			
			
			//Damage system
			var lives = 3;
			var Hlives = 3;
			// http://www.html5rocks.com/en/tutorials/pointerlock/intro/

			var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

			if ( havePointerLock ) {
				var element = document.body;
				var pointerlockchange = function ( event ) {
					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
						controlsEnabled = true;
						controls.enabled = true;
						blocker.style.display = 'none';
					} else {
						controls.enabled = false;
						blocker.style.display = '-webkit-box';
						blocker.style.display = '-moz-box';
						blocker.style.display = 'box';
						instructions.style.display = '';
					}
				};
				var pointerlockerror = function ( event ) {
					instructions.style.display = '';
				};

				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

				document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

				instructions.addEventListener( 'click', function ( event ) {
					instructions.style.display = 'none';
					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
					element.requestPointerLock();
				}, false );
			} else {
				instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
			}
			
			
			init();
			animate();
			
			
			
			function init() {
			
				 
				document.getElementById("video").volume = 0;
				//session
					$.ajax({
						type: "GET",
						url: "../session.php"
					})
					.done(function (msg) {
						if(msg != "true"){
							window.location.assign("../")
						}
					});
					
					$.ajax({
						type: "GET",
						url: "../userinfo.php"
					})
					.done(function (msg) {
						var mail = msg;
					});	
					
					$.ajax({
						type: "POST",
						url: "../updateplace.php",
					//	data: {user:mail, url: "/10.0.0.3"},
						success: function(data, textStatus, jqXHR)
						{
							//data - response from server
						},
						error: function (jqXHR, textStatus, errorThrown)
						{
					 
						}
					});
					
						
			
			
			
				//camera
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 1e10 );
				camera.position.y = -10;
				

				// scene
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0xffffff, -200, 1000 );			



				//controls
				controls = new THREE.PointerLockControls( camera );
				scene.add( controls.getObject() );

				var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true; break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 32: // space
							if ( canJump === true ) velocity.y += 350;
							canJump = false;
							break;

					}

				};

				var onKeyUp = function ( event ) {

					switch( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

					}

				};
				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );
				
				
				
						
				
				//scene.add( camera );
				

				
				//ambient
			//	var ambient = new THREE.AmbientLight( 0x444444 );
			//	scene.add( ambient );
				
				//light
				hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.1 );
				hemiLight.color.setHSL( 0, 0, 0 );
				hemiLight.groundColor.setHSL( 0, 0, 0 );
				hemiLight.position.set( 0, 500, 0 );
				scene.add( hemiLight );
				
				
				
				
				var light = new THREE.DirectionalLight( 0xebf3ff, 2 );
				light.position.set( 0, -10, 0.1 ).multiplyScalar( 1.1 );
				scene.add( light );
				light.castShadow = true;
				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;
				var d = 200;
				light.shadow.camera.left = -d;
				light.shadow.camera.right = d;
				light.shadow.camera.top = d * 1.5;
				light.shadow.camera.bottom = -d;
				light.shadow.camera.far = 3500;

				
				
				// SKYDOME
				var vertexShader = document.getElementById( 'vertexShader' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				var uniforms = {
					topColor:    { value: new THREE.Color( 0xffffff ) },
					bottomColor: { value: new THREE.Color( 0xffffff ) },
					offset:      { value: 1000 },
					exponent:    { value: 0.9 }
				};
				uniforms.topColor.value.copy( hemiLight.color );
				scene.fog.color.copy( uniforms.bottomColor.value );
				var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
				var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );
				var sky = new THREE.Mesh( skyGeo, skyMat );
				scene.add( sky );
				
				
				
				video = document.getElementById("video");
				texture = new THREE.VideoTexture( video );
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;
				texture.format = THREE.RGBFormat;
				var parameters = { color: 0xffffff, map: texture };
				material =	new THREE.MeshLambertMaterial( parameters );
				
				//mouse
				//mouse = new THREE.Vector2();
				
				
				
				// model load
				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% loaded' );
						if(Math.round(percentComplete, 2) >= 100){
							console.log("FULLY LOADED!");
						}
					}
				};
				
				
				var onError = function ( xhr ) { console.log(xhr); };
				THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );
				
				var mtlLoader = new THREE.MTLLoader();
				mtlLoader.setPath( 'mod/' );
				
				// model
				
				
				
				var manager = new THREE.LoadingManager();
				var loader = new THREE.FBXLoader( manager );
				loader.load( 'mod/entry.FBX', function( object ) {
					object.mixer = new THREE.AnimationMixer( object );
					mixers2.push( object.mixer );
					action2 = object.mixer.clipAction( object.animations[ 0 ] );
					action2.timeScale = 700;
					object.name = "entry";
					scene.add( object );
				}, onProgress, onError );
				
				var manager = new THREE.LoadingManager();
				var loader = new THREE.FBXLoader( manager );
				loader.load( 'mod/HF.FBX', function( object ) {
					object.mixer = new THREE.AnimationMixer( object );
					mixers.push( object.mixer );
					object.name = "HF";
					object.visible = false;
					action = object.mixer.clipAction( object.animations[ 0 ] );
					HF=object;
					action.play();
					scene.add( object );
				}, onProgress, onError );
				
				//lives
				mtlLoader.load( 'lives.mtl', function( materials ) {
					materials.preload();
					var objLoader = new THREE.OBJLoader();
					objLoader.setMaterials( materials );
					objLoader.setPath( 'mod/' );
					objLoader.load( 'lives.obj', function ( object ) {
						object.position.x = 0;
						object.position.y = 135;
						object.position.z = -40;
						object.visible = false;
						object.name = "lives";
						console.log(scene.children);
						HF.add( object );
					}, onProgress, onError );
				});
				

//load animations from different fbxs
//do a script to divide the animations
				
				
				//desktop
				mtlLoader.load( 'desktop.mtl', function( materials ) {
					materials.preload();
					var objLoader = new THREE.OBJLoader();
					objLoader.setMaterials( materials );
					objLoader.setPath( 'mod/' );
					objLoader.load( 'desktop.obj', function ( object ) {
						object.position.y = 0;
						object.name = "Screen1";
						scene.add( object );
					}, onProgress, onError );
				});
				
				//desktop
				mtlLoader.load( 'desktop.mtl', function( materials ) {
					materials.preload();
					var objLoader = new THREE.OBJLoader();
					objLoader.setMaterials( materials );
					objLoader.setPath( 'mod/' );
					objLoader.load( 'desktop.obj', function ( object ) {
						object.position.x = 0;
						object.position.y = 0;
						object.position.z = 0;
						object.name = "Screen2";
						scene.add( object );
					}, onProgress, onError );
				});
				//desktop
				mtlLoader.load( 'desktop.mtl', function( materials ) {
					materials.preload();
					var objLoader = new THREE.OBJLoader();
					objLoader.setMaterials( materials );
					objLoader.setPath( 'mod/' );
					objLoader.load( 'desktop.obj', function ( object ) {
						object.position.x = 0;
						object.position.y = 0;
						object.position.z = 0;
						object.name = "Screen3";
						scene.add( object );
					}, onProgress, onError );
				});
				
				
				
				//renderer
				
				renderer = new THREE.WebGLRenderer( { antialias: false } );
				
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;
				
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				container.appendChild( renderer.domElement );
				
				//stats¿?
					//stats = new Stats();
					//container.appendChild( stats.dom );
				
				//
				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', clickEvent, false );

				
				
				//Final?
				if(sessionStorage.hecpresence == 1){
					gasTime = 0.0020;
					scene.fog = new THREE.FogExp2( 0x101010, 0.0020 );
					$("#soundSwitch").remove();
				}
				
				
				
				var runnerTexture = new THREE.ImageUtils.loadTexture( 'mod/elec.png' );
				annie = new TextureAnimator( runnerTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
				var runnerMaterial = new THREE.MeshBasicMaterial( { map: runnerTexture, side:THREE.DoubleSide } );
				var runnerGeometry = new THREE.PlaneGeometry(50, 50, 1, 1);
				var runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
				runner.position.set(-100,25,0);
				scene.add(runner);
				
				
				var intensity = 2.5;
				var distance = 100;
				var decay = 2.0;
				var c1 = 0xcb0000;
				var sphere = new THREE.SphereGeometry( 0.25, 16, 8 );
				light1 = new THREE.PointLight( c1, intensity, distance, decay );
				light1.position.z = -80;
				light1.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: c1 } ) ) );
				scene.add(light1);
				
				var sphere = new THREE.SphereGeometry( 0.25, 16, 8 );
				light2 = new THREE.PointLight( c1, intensity, distance, decay );
				light2.position.x = 237;
				light2.position.y = 10;
				light2.position.z = 237;
				light2.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: c1 } ) ) );
				scene.add(light2);
				
				var sphere = new THREE.SphereGeometry( 0.25, 16, 8 );
				light3 = new THREE.PointLight( c1, intensity, distance, decay );
				light3.position.x = -222;
				light3.position.y = 10;
				light3.position.z = 250;
				light3.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: c1 } ) ) );
				scene.add(light3);
				
				// tube
				parent = new THREE.Object3D();
				parent.name = "elec";
				scene.add( parent );
				
				addTube();
				
			}
			
			
			
			function onWindowResize() {
				
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				
				
				/*
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				*/
				
				
			}

			
			
			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}
			function clickEvent( event ) {
				event.preventDefault();
				camera.updateMatrixWorld();
				raycaster.setFromCamera( mouse, camera );	
				
				
				if(terminal == 1){
					charge1 += 1.2;
				}else 
				if(terminal == 2){
					charge2 += 1.2;
				}else 
				if(terminal == 3){
					charge3 += 1.2;
				}
				
					render();
				
			}
			
			
			
			//animate
			function animate() {
				requestAnimationFrame( animate );
				if ( mixers.length > 0 ) {
					for ( var i = 0; i < mixers.length; i ++ ) {
							mixers[ i ].update( clock.getDelta() );
							mixers2[ i ].update( clock.getDelta() );
					}
				}
				
				
				
				if ( controlsEnabled ) {
					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;

					var intersections = raycaster.intersectObjects( objects );

					var isOnObject = intersections.length > 0;

					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;

					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					if ( moveForward ) velocity.z -= 700.0 * delta;
					if ( moveBackward ) velocity.z += 700.0 * delta;

					if ( moveLeft ) velocity.x -= 700.0 * delta;
					if ( moveRight ) velocity.x += 700.0 * delta;

					if ( isOnObject === true ) {
						velocity.y = Math.max( 0, velocity.y );

						canJump = false;
					}

					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );

					if ( controls.getObject().position.y < 10 ) {
						velocity.y = 0;
						controls.getObject().position.y = 10;
						canJump = false;
					}
					prevTime = time;
				}

				
				render();

			}
			
			
			function render() {
		

				camera.updateMatrixWorld();
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( scene.children[0].children );
				
				if(detectHF == 0){
					for(i=0; i < scene.children.length; i++){
						if(scene.children[i].name == "HF"){
							HF = scene.children[i];
							console.log(HF);
							var startpos = HF.position;
							detectHF = 1;
						}
					}
				}
				
				if(flag == 0){
				
				 setTimeout(function(){ 
				var flagvideo = 0;
				var length1;
					for(i = 0; i < scene.children.length && flagvideo != 1; i++){
						if(scene.children[i].children.length > 0){
						length1 = scene.children[i].children.length;
							for(j = 0; j < length1; j++){
								if(scene.children[i].children[j].name == "Box004"){
									flagvideo += 1;
									scene.children[i].children[j].material = material;
									scene.children[i].children[j+1].material = material;
									scene.children[i].children[j+2].material = material;
									scene.children[i].children[j+3].material = material;
									scene.children[i].children[j+4].material = material;
									scene.children[i].children[j+5].material = material;
									scene.children[i].children[j+6].material = material;
									scene.children[i].children[j+7].material = material;
									scene.children[i].children[j+8].material = material;
									document.getElementById("video").play();
									flag = 1;
								}								
							}
						}
					}
				}, 3000);
				}
				if(flagrs == 0){
					for(i = 0; i < scene.children.length; i++){
						if(scene.children[i].name == "Screen2"){
							screen1 = scene.children[i-1];
							screen2 = scene.children[i];
							screen3 = scene.children[i+1];
							rotateScreens();
						flagrs = 1;
						}
					}
				}
				
				
				//Animation transitions:
				if(action2){
					if(action2.time >= 7.3){
						action2.stop();
						for(i = 0; i < scene.children.length; i++){
							if(scene.children[i].name == "entry"){
								scene.children[i].visible = false;
								scene.children[i+1].visible = true;
								toCenter = 1;
							}
						}
					}
				};
				
				
				if(toCenter == 1){					
					//animation:
					HF.position.z = HF.position.z + 0.6;
					
					if(HF.position.z >= 180){ toCenter = 2;HF.children[1].visible = true;}
				}else
				if(toCenter == 2){
					
				}
				
				//console.log(scene.children[0].position);
				
				
				//areaConstrain
				
				if(scene.children[0].position.z > 362){
					scene.children[0].position.z = 362;
				}	
				if(scene.children[0].position.z < -70){
					scene.children[0].position.z = -70;
				}
				var cons1z = ((0.89*(scene.children[0].position.x))+448.33);
				var cons1x = (((scene.children[0].position.z)-448.33)/0.89);
				if(scene.children[0].position.x < cons1x){
					scene.children[0].position.x = cons1x;
				}
				
				var cons2x = (((scene.children[0].position.z)-649.18)/(-1.73));
				if(scene.children[0].position.x > cons2x){
					scene.children[0].position.x = cons2x;
				}
				
				//Area act
				var area2a = (((scene.children[0].position.z)-649.18-2)/(-1.73));
				var area2b = (((scene.children[0].position.z)-649.18+30)/(-1.73));
				var area2c = ((0.61*scene.children[0].position.x)+35.18);
				var area2d = ((0.61*scene.children[0].position.x)+140);
				
				var area3a = (((scene.children[0].position.z)-448.33-2)/0.89);
				var area3b = (((scene.children[0].position.z)-448.33+30)/0.89);
				var area3c = (((-1.11)*scene.children[0].position.x)-66.27);
				var area3d = (((-1.11)*scene.children[0].position.x)-66.27+110);
				
				//area1
				if(scene.children[0].position.z > area1.z1 && scene.children[0].position.z < area1.z2 && scene.children[0].position.x > area1.x1 && scene.children[0].position.x < area1.x2){
					terminal = 1;
				}else
				if(scene.children[0].position.x < area2a && scene.children[0].position.x > area2b && scene.children[0].position.z > area2c && scene.children[0].position.z < area2d){
					terminal = 2;
				}else
				if(scene.children[0].position.x > area3a && scene.children[0].position.x < area3b && scene.children[0].position.z > area3c && scene.children[0].position.z < area3d){
					terminal = 3;
				}else{
					terminal = 0;
				}
				
				
				
				if(charge1 < 100 && charge1 > 0){
					charge1 -=0.05;
				}else if(charge1 <= 0){
					charge1 = 0;
				}else{if(charged1 == 0){hlife(); light1.color.b=0.79; light1.color.g=0.5;light1.color.r=0; charged1 = 1;}}
				
				if(charge2 < 100 && charge2 > 0){
					charge2 -=0.05;
				}else if(charge2 <= 0){
					charge2 = 0;
				}else{if(charged2 == 0){hlife();light2.color.b=0.79; light2.color.g=0.5;light2.color.r=0; charged2 = 1;}}
				
				if(charge3 < 100 && charge3 > 0){
					charge3 -=0.05;
				}else if(charge3 <= 0){
					charge3 = 0;
				}else{if(charged3 == 0){hlife();light3.color.b=0.79; light3.color.g=0.5;light3.color.r=0; charged3 = 1;}}
				
				updatecharge();
				
				renderer.render( scene, camera );
				
				
				
				
				
				
			}
			
			
			function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) 
			{	
				// note: texture passed by reference, will be updated by the update function.
					
				this.tilesHorizontal = tilesHoriz;
				this.tilesVertical = tilesVert;
				// how many images does this spritesheet contain?
				//  usually equals tilesHoriz * tilesVert, but not necessarily,
				//  if there at blank tiles at the bottom of the spritesheet. 
				this.numberOfTiles = numTiles;
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
				texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

				// how long should each image be displayed?
				this.tileDisplayDuration = tileDispDuration;

				// how long has the current image been displayed?
				this.currentDisplayTime = 0;

				// which image is currently being displayed?
				this.currentTile = 0;
					
				this.update = function( milliSec )
				{
					this.currentDisplayTime += milliSec;
					while (this.currentDisplayTime > this.tileDisplayDuration)
					{
						this.currentDisplayTime -= this.tileDisplayDuration;
						this.currentTile++;
						if (this.currentTile == this.numberOfTiles)
							this.currentTile = 0;
						var currentColumn = this.currentTile % this.tilesHorizontal;
						texture.offset.x = currentColumn / this.tilesHorizontal;
						var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
						texture.offset.y = currentRow / this.tilesVertical;
					}
				};
			}		
			
function startH()
{
	action2.repetitions = 0;
	action2.clampWhenFinished = true;
	action2.play();
}

var rotObjectMatrix;
function rotateAroundObjectAxis(object, axis, radians) {
    rotObjectMatrix = new THREE.Matrix4();
    rotObjectMatrix.makeRotationAxis(axis.normalize(), radians);

    // old code for Three.JS pre r54:
    // object.matrix.multiplySelf(rotObjectMatrix);      // post-multiply
    // new code for Three.JS r55+:
    object.matrix.multiply(rotObjectMatrix);

    // old code for Three.js pre r49:
    // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
    // old code for Three.js r50-r58:
    // object.rotation.setEulerFromRotationMatrix(object.matrix);
    // new code for Three.js r59+:
    object.rotation.setFromRotationMatrix(object.matrix);
}


var rotWorldMatrix;
// Rotate an object around an arbitrary axis in world space       
function rotateAroundWorldAxis(object, axis, radians) {
    rotWorldMatrix = new THREE.Matrix4();
    rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);

    // old code for Three.JS pre r54:
    //  rotWorldMatrix.multiply(object.matrix);
    // new code for Three.JS r55+:
    rotWorldMatrix.multiply(object.matrix);                // pre-multiply

    object.matrix = rotWorldMatrix;

    // old code for Three.js pre r49:
    // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
    // old code for Three.js pre r59:
    // object.rotation.setEulerFromRotationMatrix(object.matrix);
    // code for r59+:
    object.rotation.setFromRotationMatrix(object.matrix);
}

function rotateScreens(){

				
	var xAxis = new THREE.Vector3(0,1,0);
	asf = screen2;
	rotateAroundWorldAxis(asf, xAxis, Math.PI/1.3);
	asf.position.x = -180;
	asf.position.y = 0;
	asf.position.z = 200;
	
	var xAxis = new THREE.Vector3(0,-1,0);
	asf = screen3;
	rotateAroundWorldAxis(asf, xAxis, Math.PI/1.5);
	asf.position.x = 180;
	asf.position.y = 0;
	asf.position.z = 200;

}	


function hlife(){
	Hlives -= 1;
	console.log(Hlives);
	if(Hlives == 2){
		HF.children[1].children[0].visible = false;
	}
	if(Hlives == 1){
		HF.children[1].children[1].visible = false;
	}
	if(Hlives == 0){
		HF.children[1].children[2].visible = false;
		
	}
}

function life(){
	lives -=1;
	if(lives == 0){
		
	}
}	
	
	//charge1 charge2 charge3
function updatecharge(){
	if(charge1 >= 100){
		charge1 = 100.01;
	}
	if(charge2 >= 100){
		charge2 = 100.01;
	}
	if(charge3 >= 100){
		charge3 = 100.01;
	}
	document.getElementById("charge1").innerHTML = Math.floor(charge1)+"%";
	document.getElementById("charge1").style.width = charge1+"%";
	document.getElementById("charge2").innerHTML = Math.floor(charge2)+"%";
	document.getElementById("charge2").style.width = charge2+"%";
	document.getElementById("charge3").innerHTML = Math.floor(charge3)+"%";
	document.getElementById("charge3").style.width = charge3+"%";
}	

function addTube() {
		if ( group !== undefined ) {
			scene.remove( group );
			group.children[ 0 ].geometry.dispose();
			group.children[ 1 ].geometry.dispose();
		}
		extrudePath = splines[ rayparams.spline ];
		tubeGeometry = new THREE.TubeBufferGeometry( extrudePath, rayparams.extrusionSegments, 2, rayparams.radiusSegments, rayparams.closed );
		addGeometry( tubeGeometry );
	}

function addGeometry( geometry ) {
			// 3D shape
			group = THREE.SceneUtils.createMultiMaterialObject( geometry, [ raymaterial, wireframeMaterial ] );
			
			parent.add( group );
			
		}

		</script>

	</body>
</html>